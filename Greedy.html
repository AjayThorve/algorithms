<html>
    <head>
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Design and Analysis of Algorithms: Greedy Algorithms
        </title>
    </head>

    <body>
        <h1>
            Design and Analysis of Algorithms: Greedy Algorithms
        </h1>

            <div style="text-align:center">
                <p>
                    <img
                    src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bc/The_worship_of_Mammon.jpg/170px-The_worship_of_Mammon.jpg">
                    <br>
                </p>
            </div>

            <h2>
                What is a greedy algorithm?
            </h2>

                <p>
                We have an optimization problem.
                <br>
                At each step of the algorithm, we have to make a choice, e.g.,
                cut the rod here, or cut it there.
                <br>
                Sometimes, we need to calculate the result of all possible
                choices.
                </p>
                <ul>
                    <li>When we do so from the top down, we have a <i>recursive
                    algorithm</i>. A naive recursive algorithm may be very
                    expensive, but we can significantly reduce its run-time by
                    <i>memoizing</i> it.
                    <li>When we do this calculation from the bottom up, we are
                        employing <i>dynamic programming</i>.
                </ul>

                <p>
                But sometimes, we can do much better than either of those
                choices. Sometimes, we don't need to consider the global
                situation at all: we can simply make the best choice among the
                options provided by the first sub-problem we face, and then
                continue that procedure for all subsequent sub-problems.
                <br>
                <br>
                An algorithm that operates in such a fashion is a <i>greedy
                algorithm</i>. (The name comes from the idea that the
                algorithm <i>greedily</i> grabs the best choice available to it right
                away.)
                <br>
                <br>
                Clearly, not all problems can be solved by greedy algorithms.
                Consider this simple shortest path problem:
                <br>
                <br>
                <img src="graphics/ShortPath.png">
                <br>
                <br>
                A greedy algorithm choosing the shortest path from <i>a</i> to <i>d</i> will
                wrongly head to <i>b</i> first, rather than to <i>c</i>.
                <br>
                <br>
                And that provides us a <a href="#hw1">homework problem</a>.
                <br>
                </p>

                <h3>
                    Minimum spanning trees
                </h3>

                    <p>
                    <b>Tree</b>: A connected graph with no cycles.
                    <br>
                    Given a graph G, any tree that includes all of the vertices
                    of G is called a <i>spanning tree</i>. The lowest-weight tree
                    that does that is a <i>minimum spanning tree</i>.
                    <br>
                    <br>
                    These are used to solve problems such as:
                    </p>
                    <ul>
                        <li>Lowest cost way to bring a package between two
                            cities.
                        <li>Most efficient way to connect two components on a
                            circuit board.
                        <li>Most efficient way to connect two strangers in a
                            social network.
                    </ul>
                    <p>
                    Our first greedy algorithm.
                    <br>
                    <br>
                    Weighted graph.
                    </p>

                    <h4>
                        Kruskal's Algorithm
                    </h4>

                    <p>
                    <img src="graphics/MinSpanTree1.png">
                    <br>
                    <br>
                    Steps:
                    </p>
                    <ul>
                        <li>Include the edge weighted 1.
                        <li>Include both edges weighted 2.
                        <li>Include the edge weighted 3.
                        <li>Include the upper
                            and lower edges weighted 4.
                            (Not the middle one!)
                        <li>Include the lone edge weighted 5.
                        <li>Include the edge weighted 6.
                    </ul>
                    <p>
                    <img src="graphics/MinSpanTree2.png">
                    <br>
                    <br>
                    <b>Proof</b>: Is Kruskal's algorithm guaranteed to always
                    find the minimum spanning tree?
                    <br>
                    Yes, it is. Let's prove it. 
                    <br>
                    We suppose that graph <i>G</i> has <i>n</i> vertices.
                    Then our algorithm will create a tree <i>T</i>
                    with edges <i>e<sub>1</sub></i>, <i>e<sub>2</sub></i>,
                    ...  <i>e<sub>n - 1</sub></i>, where 
                    <i>w(e<sub>1</sub>) < w(e<sub>2</sub>)
                        < ... w(e<sub>n - 1</sub>)</i>.
                    <br>
                    Suppose that there is a tree <i>T*</i> with a lesser
                    weight.
                    <br>
                    Let <i>e<sub>k</sub></i> be the first edge in <i>T</i>
                    that is not in <i>T*</i>.
                    <br>
                    Now we insert <i>e<sub>k</sub></i> in <i>T*</i>. This will
                    produce a cycle in <i>T*</i>, by the nature of trees.
                    There must be some edge <i>e<sup>*</sup></i> that is in
                    <i>T*</i> but not in <i>T</i> (otherwise <i>T</i> would
                    have a cycle).
                    <br>
                    But the weight of <i>e<sub>k</sub></i> must be less than
                    the weight of <i>e<sup>*</sup></i>, because after we had
                    inserted <i>e<sub>1</sub></i> through 
                    <i>e<sub>k - 1</sub></i>, we could have next chosen
                    <i>e<sup>*</sup></i>... but we did not. Instead we chose
                    <i>e<sub>k</sub></i>.
                    <br>
                    So <i>T*</i> does not have a lesser weight after all.
                    </p>


            <h2>
                An activity selection problem
            </h2>

                <h3>
                    The optimal sub-structure of the problem
                </h3>

                <h3>
                    Making the greedy choice
                </h3>

                <h3>
                    A recursive greedy algorithm
                </h3>

                <h3>
                    An iterative greedy algorithm
                </h3>

            <h2>
                Elements of the greedy strategy
            </h2>

                <h3>
                    Greedy-choice property
                </h3>


                <h3>
                    Optimal substructure
                </h3>


                <h3>
                    Greedy versus dynamic programming
                </h3>

            <h2>
                Huffman codes
            </h2>

                <h3>
                    Prefix codes
                </h3>

                <h3>
                    Constructing a Huffman code
                </h3>

                <h3>
                    Correctness of Huffman's algorithm
                </h3>


            <h2>
                Matroids and greedy methods
            </h2>

            <h2>
                Source Code
            </h2>
                <p>
                    <a
                        href="https://github.com/gcallah/algorithms/blob/master/python/greedy.py">
                    Python
                    </a>
                    <br>
                    <a
                        href="https://github.com/gcallah/algorithms/blob/master/ruby/greedy.rb">
                        Ruby
                    </a>
                </p>

            <h2>
                External Links
            </h2>
                <ul>
                    <li>
                </ul>
            
            <h2>
                Homework
            </h2>
                <ol>
                    <li id="hw1">
                    Our intuition might tell us that choosing the shortest path
                    from MetroTech Center to Yankee Stadium is a simpler problem
                    than choosing a minimum spanning tree for all New York subway
                    stations. Yet the latter can be solved with a greedy algorithm,
                    while the first cannot. Why?
                    <li>Why is the run-time analysis of the rod cutting problem not
                    the same as that of the matrix chain problem?
                </ol>
    </body>
</html>
