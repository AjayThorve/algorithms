<html>
    <body>
        <h1>Lecture 1 (Sept 12, 2016): Introduction and preliminaries<a
                href="#note1">*</a></h1>

    <ul>
      <li>Introduction.
      <br>
      Syllabus: Logistics, grading, exams, homeworks, cheating. 
      <li>We will study algorithms.
      <br><b>What's an algorithm?</b>
      A carefully written recipe.<br>
      We need to agree what steps are allowed in a recipe.<br>
      We need to agree what problem the recipe is solving, ahead of time.
      <li>Things to keep in mind about algorithms (when analyzing and/or designing them): <ul>
        <li>Termination: On any legal (meaning, consistent with algorithm specification) input,
        the procedure you are describing should always eventually stop, or <i>terminate</i>.
        (In this course we will not talk about algorithms that are intended to run "forever,"
        such as the scheduler in an operating system.)
        <li>Correctness: On any legal input, provided the procedure has terminated,
        the result that it produces has to be correct. Not <em>sometimes</em> correct,
        not <em>mostly</em> correct, but <em>always</em> correct.
        <li>And finally, performance: You can measure performance in many different ways.
        The course will focus on the running time,
        but there are many others: space (memory use),
        disk use, amount of disk-memory communication,
        number of processors in a parallel program,
        total amount of work in a parallel program,
        number of cores in a multi-core program,
        total amount of communication in a distributed program,
        power consumed in an algorithm tuned to low-power devices and many many others.
      </ul>
      So in short, when you describe a recipe for doing something, make sure it always stops,
      make sure it always produces correct answers, and only after that worry about how
      efficient it is. (Depending on the algorithm, some or all of these are very
      easy, and some may not be obvious at all. We will see examples later.)
     <li>Focusing on running time, we surely do not want to talk about actual time
     in nanoseconds, as that depends on too many external things: what other
     processes are running, details of the hardware, compiler switches, etc, etc. 
    So instead we come up with a very primitive <em>abstract machine</em> (RAM=the
    Random Access Machine: CPU + directly addressable memory) which we analyze instead
    of a real computer.  Then primitive operations are memory reads/writes and operations
    in the CPU, such as address arithmetic, additions, multiplications, divisions,
    etc. Our idea of "running time" is then simply the number of operations
    performed when the program runs.
      <li>More trouble: even for inputs of a fixed size (saying, your favorite program
      sorting 10 numbers), different specific inputs will produce different performance.
      For example, a clever algorithm may notice that the input is already sorted
      and not try sorting it again. So, we distinguish between best- and worst-case
      performance (minimum and maximum number of operations performed by the algorithm,
      over all possible legal inputs of a given size). (There is also the concept of
      "average-case," but it is tricky, as it requires a definition of what average
      means: technically, you need to specify a <i>distribution</i> of the inputs.
      We will mostly stay away from average-case analysis and focus on the worst case;
      we will occasionally look at the best case too.)
      <li>What we really want, is not the running time (as the number of operations,
      say, in the worst case), for a specific input size, but as a function of the
      input size, over all sizes. For example, it may be that a given sorting
      algorithm requires $$4n^2-4n+24$$ operations to sort $$n$$ items.
      <li>In order to make life easier, we will not be focusing on the exact value of
      such function, but on its <i>asymptotic</i> behavior.
      <br>
      <br>
        <center>
        <img
        src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Comparison_computational_complexity.svg/250px-Comparison_computational_complexity.svg.png">
        </center>
        <hr>
      <br>
      A quick review:
        <br>
        <br>
        <ul>
            <li> big-Oh: O
            <br>
            <img
            src="https://upload.wikimedia.org/wikipedia/commons/8/89/Big-O-notation.png">
            <li> big-Theta: &Theta;
            <li> big-Omega: &Omega;
            <li>little-oh: o
            <li>little-omega: &omega;
        </ul>
      You should review them in the book.
      It's a language I am going to use throughout the course. If you are not
      comfortable with it, you will be lost. 
        <li>An example of a toy algorithmic problem and how to solve it, analyze it etc etc.
    </ul>
    <a name="note1">* Based on Prof. Boris Aronov's lecture notes. </a>
    </body>
</html>
